<!DOCTYPE html>
<html>
<head>
<title>python协程.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="python%E5%8D%8F%E7%A8%8B">python协程</h1>
<p>个人简介：
wedo实验君, 数据分析师；热爱生活，热爱写作</p>
<h2 id="1-%E5%8D%8F%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5">1. 协程相关的概念</h2>
<h3 id="11-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B">1.1 进程和线程</h3>
<p>进程（Process）是应用程序启动的实例，拥有代码、数据和文件和独立的内存空间，是操作系统最小资源管理单元。每个进程下面有一个或者多个线程（Thread），来负责执行程序的计算，是最小的执行单元。</p>
<p>重点是：操作系统会负责进程的资源的分配；控制权主要在操作系统。
另一方面，线程做为任务的执行单元，有<code>新建</code>、<code>可运行runnable</code>（调用start方法，进入调度池，等待获取cpu使用权）、<code>运行running（得到cpu使用权开始执行程序）</code> <code>阻塞blocked（放弃了cpu 使用权，再次等待）</code> <code>死亡dead</code>5中不同的状态。线程的转态也是由操作系统进行控制。线程如果存在资源共享的情况下，就需要加锁，比如生产者和消费者模式，生产者生产数据多共享队列，消费者从共享队列中消费数据。</p>
<p>线程和进程在得到和放弃cpu使用权时，cpu使用权的切换都需损耗性能，因为某个线程为了能够在再次获得cpu使用权时能继续执行任务，必须记住上一次执行的所有状态。另外线程还有锁的问题。</p>
<h3 id="12-%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91">1.2 并行和并发</h3>
<p>并行和并发，听起来都像是同时执行不同的任务。但是这个同时的含义是不一样的。</p>
<ul>
<li>并行： 多核CPU才有可能真正的同时执行，就是独立的资源来完成不同的任务，没有先后顺序。</li>
<li>并发（concurrent）： 是看上去的同时执行，实际微观层面是顺序执行，是操作系统对进程的调度以及cpu的快速上下文切换，每个进程执行一会然后停下来，cpu资源切换到另一个进程，只是切换的时间很短，看起来是多个任务同时在执行。要实现大并发，需要把任务切成小的任务。</li>
</ul>
<p>上面说的多核cpu可能同时执行，这里的可能是和操作系统调度有关，如果操作系统调度到同一个cpu，那就需要cpu进行上下文切换。当然多核情况下，操作系统调度会尽可能考虑不同cpu。</p>
<p>这里的上下文切换可以理解为需要保留不同执行任务的状态和数据。所有的并发处理都有排队等候，唤醒，执行至少三个这样的步骤</p>
<h3 id="13-%E5%8D%8F%E7%A8%8B">1.3 协程</h3>
<p>我们知道线程的提出是为了能够在多核cpu的情况下，达到并行的目的。而且线程的执行完全是操作系统控制的。而协程（Coroutine）是线程下的，控制权在于用户，本质是为了能让多组过程能不独自占用完所有资源，在一个线程内交叉执行，达到高并发的目的。</p>
<p>协程的优势：</p>
<ul>
<li>协程最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显</li>
<li>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li>
</ul>
<p>协程和线程区别：</p>
<ul>
<li>协程都没参与多核CPU并行处理，协程是不并行</li>
<li>线程在多核处理器上是并行在单核处理器是受操作系统调度的</li>
<li>协程需要保留上一次调用的状态</li>
<li>线程的状态有操作系统来控制</li>
</ul>
<p>我们姑且也过一遍这些文字上的概念，<code>show your code</code>的时候再联系起来，就会更清晰的。</p>
<h2 id="2-python%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B">2. python中的线程</h2>
<p>python中的线程由于历史原因，即使在多核cpu的情况下并不能达真正的并行。这个原因就是全局解释器锁GIL（global interpreter lock），准确的说GIL不是python的特性，而是cpython引入的一个概念。cpython解释器在解析多线程时，会上GIL锁，保证同一时刻只有一个线程获取CPU使用权。</p>
<ul>
<li>为什么需要GIL
python中一切都是对象，Cpython中对象的回收，是通过对象的引用计数来判断，当对象的引用计数为0时，就会进行垃圾回收，自动释放内存。但是如果多线程的情况，引用计数就变成了一个共享的变量
Cpython是当下最流行的Python的解释器，使用引用计数来管理内存，在Python中，一切都是对象，引用计数就是指向对象的指针数，当这个数字变成0，则会进行垃圾回收，自动释放内存。但是问题是Cpython是线程不安全的。</li>
</ul>
<p>考虑下如果有两个线程A和B同时引用一个对象obj，这个时候obj的引用计数为2；A打算撤销对obj的引用，完成第一步时引用计数减去1时，这时发生了线程切换，A挂起等待，还没执行销毁对象操作。B进入运行状态，这个时候B也对obj撤销引用，并完成引用计数减1，销毁对象，这个时候obj的引用数为0，释放内存。如果此时A重新唤醒，要继续销毁对象，可是这个时候已经没有对象了。 所以为了保证不出现数据污染，才引入GIL。</p>
<p>每个线程使用前都会去获取GIL权限，使用完释放GIL权限。释放线程的时机由python的另一个机制check_interval来决定。</p>
<p>在多核cpu时，因为需要获取和释放GIL锁，会存在性能上额外的损耗。特别是由于调度控制的原因，比如一个线程释放了锁，调度接着又分配cpu资源给同一个线程，该线程发起申请时，又重新获得GIL，而其他线程实际上都在等待，白白浪费了申请和释放锁的操作耗时。</p>
<p>python中的线程比较适合I/O密集型的操作（磁盘IO或者网络IO）。</p>
<p><img src="img/md-2020-12-11-00-31-29.png" alt=""></p>
<ul>
<li>线程的使用</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">from</span> concurrent <span class="hljs-keyword">import</span> futures

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_do</span><span class="hljs-params">(info)</span>:</span>  
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100000000</span>):
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">return</span> info[<span class="hljs-number">0</span>]

MAX_WORKERS = <span class="hljs-number">10</span>
param_list = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):
    param_list.append((<span class="hljs-string">'text%s'</span> % i, <span class="hljs-string">'info%s'</span> % i))

workers = min(MAX_WORKERS, len(param_list))
<span class="hljs-comment"># with 默认会等所有任务都完成才返回，所以这里会阻塞</span>
<span class="hljs-keyword">with</span> futures.ThreadPoolExecutor(workers) <span class="hljs-keyword">as</span> executor:
    results = executor.map(to_do, sorted(param_list))

<span class="hljs-comment"># 打印所有</span>
<span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:
    print(result)

<span class="hljs-comment"># 非阻塞的方式，适合不需要返回结果的情况</span>
workers = min(MAX_WORKERS, len(param_list))
executor = futures.ThreadPoolExecutor(workers)
results = []
<span class="hljs-keyword">for</span> idx, param <span class="hljs-keyword">in</span> enumerate(param_list):
    result = executor.submit(to_do, param)
    results.append(result)
    print(<span class="hljs-string">'result %s'</span> % idx)

<span class="hljs-comment"># 手动等待所有任务完成</span>
executor.shutdown()
print(<span class="hljs-string">'='</span>*<span class="hljs-number">10</span>)
<span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:
    print(result.result())
</div></code></pre>
<h2 id="3-python%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B">3. python中的进程</h2>
<p>python提供的<code>multiprocessing</code>包来规避GIL的缺点，实现在多核cpu上并行的目的。<code>multiprocessing</code>还提供进程之间数据和内存共享的机制。这里介绍的<code>concurrent.futures</code>的实现。 用法和线程基本一样，ThreadPoolExecutor改成ProcessPoolExecutor</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">from</span> concurrent <span class="hljs-keyword">import</span> futures

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_do</span><span class="hljs-params">(info)</span>:</span>  
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10000000</span>):
        <span class="hljs-keyword">pass</span>
    <span class="hljs-keyword">return</span> info[<span class="hljs-number">0</span>]

start_time = time.time()
MAX_WORKERS = <span class="hljs-number">10</span>
param_list = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):
    param_list.append((<span class="hljs-string">'text%s'</span> % i, <span class="hljs-string">'info%s'</span> % i))

workers = min(MAX_WORKERS, len(param_list))
<span class="hljs-comment"># with 默认会等所有任务都完成才返回，所以这里会阻塞</span>
<span class="hljs-keyword">with</span> futures.ProcessPoolExecutor(workers) <span class="hljs-keyword">as</span> executor:
    results = executor.map(to_do, sorted(param_list))
    
<span class="hljs-comment"># 打印所有</span>
<span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:
    print(result)
print(time.time()-start_time)
<span class="hljs-comment"># 耗时0.3704512119293213s， 而线程版本需要14.935384511947632s</span>
</div></code></pre>
<h2 id="4-python%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B">4. python中的协程</h2>
<h3 id="41-%E7%AE%80%E5%8D%95%E5%8D%8F%E7%A8%8B">4.1 简单协程</h3>
<p>我们先来看下python是怎么实现协程的。 答案是yield。 以下例子的功能是实现计算移动平均数</p>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple
Result = namedtuple(<span class="hljs-string">'Result'</span>, <span class="hljs-string">'count average'</span>)

<span class="hljs-comment"># 协程函数</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">averager</span><span class="hljs-params">()</span>:</span>
    total = <span class="hljs-number">0.0</span>
    count = <span class="hljs-number">0</span>
    average = <span class="hljs-literal">None</span>
    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
        term = <span class="hljs-keyword">yield</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 暂停，等待主程序传入数据唤醒</span>
        <span class="hljs-keyword">if</span> term <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 决定是否退出</span>
        total += term
        count += <span class="hljs-number">1</span>
        average = total/count <span class="hljs-comment"># 累计状态，包括上一次的状态</span>
    <span class="hljs-keyword">return</span> Result(count, average)

<span class="hljs-comment"># 协程的触发</span>
coro_avg = averager()
<span class="hljs-comment"># 预激活协程</span>
next(coro_avg)

<span class="hljs-comment"># 调用者给协程提供数据</span>
coro_avg.send(<span class="hljs-number">10</span>)
coro_avg.send(<span class="hljs-number">30</span>)
coro_avg.send(<span class="hljs-number">6.5</span>)
<span class="hljs-keyword">try</span>:
    coro_avg.send(<span class="hljs-literal">None</span>)
<span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> exc: <span class="hljs-comment"># 执行完成，会抛出StopIteration异常，返回值包含在异常的属性value里</span>
    result = exc.value

print(result)
</div></code></pre>
<p><code>yield</code>关键字有两个含义：产出和让步;  把yield的右边的值产出给调用方，同时做出让步，暂停执行，让程序继续执行。</p>
<p>上面的例子可知</p>
<ul>
<li>协程用yield来控制流程，接收和产出数据</li>
<li>next()： 预激活协程</li>
<li>send： 协程从调用方接收数据</li>
<li>StopIteration：控制协程结束， 同时获取返回值</li>
</ul>
<p>我们来回顾下1.3中协程的概念：<strong><code>本质是为了能让多组过程能不独自占用完所有资源，在一个线程内交叉执行，达到高并发的目的。</code></strong>。 上面的例子怎么解释呢？</p>
<ul>
<li>可以把一个协程单次一个任务，即移动平均</li>
<li>每个任务可以拆分成小步骤（也可以说是子程序), 即每次算一个数的平均</li>
<li>如果多个任务需要执行呢？ 怎么调用控制器在调用方</li>
<li>如果有10个，可以想象，调用在控制的时候随机的给每个任务send的一个数据化，就会是多个任务在交叉执行，达到并发的目的。</li>
</ul>
<h3 id="42-asyncio%E5%8D%8F%E7%A8%8B%E5%BA%94%E7%94%A8%E5%8C%85">4.2 asyncio协程应用包</h3>
<p>asyncio即异步I/O, 如在高并发（如百万并发）网络请求。异步I/O即你发起一个I/O操作不必等待执行结束，可以做其他事情。asyncio底层是协程的方式来实现的。
我们先来看一个例子，了解下<code>asyncio</code>的五脏六腑。</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> asyncio

now = <span class="hljs-keyword">lambda</span> : time.time()

<span class="hljs-comment"># async定义协程</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_some_work</span><span class="hljs-params">(x)</span>:</span>
    print(<span class="hljs-string">"waiting:"</span>,x)
    <span class="hljs-comment"># await挂起阻塞， 相当于yield， 通常是耗时操作</span>
    <span class="hljs-keyword">await</span> asyncio.sleep(x)
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Done after {}s"</span>.format(x)

<span class="hljs-comment"># 回调函数，和yield产出类似功能</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">callback</span><span class="hljs-params">(future)</span>:</span>
    print(<span class="hljs-string">"callback:"</span>,future.result())

start = now()
tasks = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):
    <span class="hljs-comment"># 定义多个协程，同时预激活</span>
    coroutine = do_some_work(i)
    task = asyncio.ensure_future(coroutine)
    task.add_done_callback(callback)
    tasks.append(task)

<span class="hljs-comment"># 定一个循环事件列表，把任务协程放在里面，</span>
loop = asyncio.get_event_loop()
<span class="hljs-keyword">try</span>:
    <span class="hljs-comment"># 异步执行协程，直到所有操作都完成， 也可以通过asyncio.gather来收集多个任务</span>
    loop.run_until_complete(asyncio.wait(tasks))
    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> tasks:
        print(<span class="hljs-string">"Task ret:"</span>,task.result())
<span class="hljs-keyword">except</span> KeyboardInterrupt <span class="hljs-keyword">as</span> e: <span class="hljs-comment"># 协程任务的状态控制</span>
    print(asyncio.Task.all_tasks())
    <span class="hljs-keyword">for</span> task <span class="hljs-keyword">in</span> asyncio.Task.all_tasks():
        print(task.cancel())
    loop.stop()
    loop.run_forever()
<span class="hljs-keyword">finally</span>:
    loop.close()

print(<span class="hljs-string">"Time:"</span>, now()-start)
</div></code></pre>
<p>上面涉及到的几个概念：</p>
<ul>
<li>event_loop 事件循环：程序开启一个无限循环，把一些函数注册到事件循环上，当满足事件发生的时候，调用相应的协程函数</li>
<li>coroutine 协程：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。</li>
<li>task任务：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含了任务的各种状态</li>
<li>future: 代表将来执行或没有执行的任务的结果。它和task上没有本质上的区别</li>
<li>async/await 关键字：python3.5用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口。
从上面可知，<code>asyncio</code>通过事件的方式帮我们实现了协程调用方的控制权处理，包括send给协程数据等。我们只要通过<code>async</code>定义协程，<code>await</code>定义阻塞，然后封装成future的task，放入循环的事件列表中，就等着返回数据。</li>
</ul>
<p>再来看一个http下载的例子，比如你想下载5个不同的url（同样的，你想接收外部的百万的请求）</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> asyncio
<span class="hljs-keyword">from</span> aiohttp <span class="hljs-keyword">import</span> ClientSession

tasks = []
url = <span class="hljs-string">"https://www.baidu.com/{}"</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hello</span><span class="hljs-params">(url)</span>:</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> ClientSession() <span class="hljs-keyword">as</span> session:
        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> response:
            response = <span class="hljs-keyword">await</span> response.read()
<span class="hljs-comment">#            print(response)</span>
            print(<span class="hljs-string">'Hello World:%s'</span> % time.time())

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    loop = asyncio.get_event_loop()
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):
        task = asyncio.ensure_future(hello(url.format(i)))
        tasks.append(task)
    loop.run_until_complete(asyncio.wait(tasks))
</div></code></pre>
<h3 id="43-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">4.3 协程的应用场景</h3>
<ul>
<li>支撑高并发I/O情况，如写支撑高并发的服务端</li>
<li>代替线程，提供并发性能</li>
<li>tornado和gevent都实现了类似功能， 之前文章提到Twisted也是</li>
</ul>
<h2 id="5-%E6%80%BB%E7%BB%93">5. 总结</h2>
<p>本文分享关于python协程的概念和asyncio包的初步使用情况，同时也介绍了基本的相关概念，如进程、线程、并发、并行等。希望对你有帮助，欢迎交流（@mintel）。简要总结如下：</p>
<ul>
<li>并发和并行不一样，并行是同时执行多个任务， 并发是在极短时间内处理多个任务</li>
<li>多核cpu，进程是并行，python线程受制于GIL，不能并行，反而因为上下文切换更耗时，协程正好可以弥补</li>
<li>协程也不是并行，只是任务交替执行任务，在存在阻塞I/O情况，能够异步执行，提高效率</li>
<li>asyncio 异步I/O库，可用于开发高并发应用</li>
</ul>

</body>
</html>
